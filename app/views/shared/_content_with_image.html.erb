<%
  # Split content into paragraphs
  paragraphs = content.split(/\n\n+/)
  
  # Handle both single image (legacy) and multiple images (new)
  images_to_insert = []
  if defined?(insert_image) && insert_image
    images_to_insert << {
      image: insert_image,
      position: defined?(after_paragraph) ? after_paragraph : 12
    }
  end
  
  if defined?(insert_images) && insert_images
    images_to_insert.concat(insert_images)
  end
  
  # Create gallery data for all images on the page
  all_page_images = images_to_insert.map do |img_config|
    {
      src: image_path(img_config[:image][:src]),
      alt: img_config[:image][:alt]
    }
  end
  gallery_data_json = { images: all_page_images }.to_json
  
  # Build the output
  output_html = []
  paragraphs.each_with_index do |paragraph, index|
    # Add paragraph wrapped in <p> tags
    output_html << content_tag(:p, paragraph.strip) unless paragraph.strip.empty?
    
    # Group images that should appear after this paragraph
    images_for_position = images_to_insert.select { |img| img[:position] - 1 == index }
    
    if images_for_position.any?
      if images_for_position.length > 1
        # Multiple images - display side by side
        images_html = images_for_position.map do |img_config|
          image_classes = "embedded-image"
          image_classes += " #{img_config[:image][:class]}" if img_config[:image][:class]
          
          # Find the index of this image in the complete gallery
          current_index = all_page_images.find_index { |img| img[:src] == image_path(img_config[:image][:src]) }
          gallery_with_index = { images: all_page_images, currentIndex: current_index }.to_json
          
          image_html = image_tag(img_config[:image][:src], 
                                alt: img_config[:image][:alt], 
                                class: image_classes,
                                data: { gallery_data: html_escape(gallery_with_index) },
                                onclick: "window.openImageGallery(JSON.parse(this.getAttribute('data-gallery-data'))); return false;",
                                style: "cursor: pointer;")
          content_tag(:div, image_html, class: "side-by-side-image")
        end
        output_html << content_tag(:div, safe_join(images_html), class: "embedded-image-container side-by-side")
      else
        # Single image
        img_config = images_for_position.first
        image_classes = "embedded-image"
        image_classes += " #{img_config[:image][:class]}" if img_config[:image][:class]
        
        # Find the index of this image in the complete gallery
        current_index = all_page_images.find_index { |img| img[:src] == image_path(img_config[:image][:src]) }
        gallery_with_index = { images: all_page_images, currentIndex: current_index }.to_json
        
        image_html = image_tag(img_config[:image][:src], 
                              alt: img_config[:image][:alt], 
                              class: image_classes,
                              data: { gallery_data: html_escape(gallery_with_index) },
                              onclick: "window.openImageGallery(JSON.parse(this.getAttribute('data-gallery-data'))); return false;",
                              style: "cursor: pointer;")
        output_html << content_tag(:div, image_html, class: "embedded-image-container")
      end
    end
  end
  
  # If we haven't inserted any images yet (fewer paragraphs than specified), add them at the end
  remaining_images = images_to_insert.select { |img| paragraphs.length < img[:position] }
  
  # Group remaining images by position
  remaining_by_position = remaining_images.group_by { |img| img[:position] }
  
  remaining_by_position.each do |position, images|
    if images.length > 1
      # Multiple images - display side by side
      images_html = images.map do |img_config|
        image_classes = "embedded-image"
        image_classes += " #{img_config[:image][:class]}" if img_config[:image][:class]
        
        # Find the index of this image in the complete gallery
        current_index = all_page_images.find_index { |img| img[:src] == image_path(img_config[:image][:src]) }
        gallery_with_index = { images: all_page_images, currentIndex: current_index }.to_json
        
        image_html = image_tag(img_config[:image][:src], 
                              alt: img_config[:image][:alt], 
                              class: image_classes,
                              data: { gallery_data: html_escape(gallery_with_index) },
                              onclick: "window.openImageGallery(JSON.parse(this.getAttribute('data-gallery-data'))); return false;",
                              style: "cursor: pointer;")
        content_tag(:div, image_html, class: "side-by-side-image")
      end
      output_html << content_tag(:div, safe_join(images_html), class: "embedded-image-container side-by-side")
    else
      # Single image
      img_config = images.first
      image_classes = "embedded-image"
      image_classes += " #{img_config[:image][:class]}" if img_config[:image][:class]
      
      # Find the index of this image in the complete gallery
      current_index = all_page_images.find_index { |img| img[:src] == image_path(img_config[:image][:src]) }
      gallery_with_index = { images: all_page_images, currentIndex: current_index }.to_json
      
      image_html = image_tag(img_config[:image][:src], 
                            alt: img_config[:image][:alt], 
                            class: image_classes,
                            data: { gallery_data: html_escape(gallery_with_index) },
                            onclick: "window.openImageGallery(JSON.parse(this.getAttribute('data-gallery-data'))); return false;",
                            style: "cursor: pointer;")
      output_html << content_tag(:div, image_html, class: "embedded-image-container")
    end
  end
%>

<%= safe_join(output_html) %>

