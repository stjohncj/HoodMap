#!/bin/bash -e

# Enable jemalloc for reduced memory usage and latency.
if [ -z "${LD_PRELOAD+x}" ]; then
    LD_PRELOAD=$(find /usr/lib -name libjemalloc.so.2 -print -quit)
    export LD_PRELOAD
fi

# Fix storage directory permissions (runs as root before dropping privileges)
# This ensures the rails user can write to storage for Active Storage uploads
echo "Fixing storage directory permissions..."
mkdir -p /rails/storage
chown -R rails:rails /rails/storage
chmod 755 /rails/storage
echo "Storage directory ready: $(ls -la /rails | grep storage)"

# If running the rails server (either directly or via docker-start wrapper)
# then create or migrate existing database
if [[ "${@: -2:1}" == "./bin/rails" && "${@: -1:1}" == "server" ]] || [[ "$1" == "./bin/docker-start" ]]; then
  echo "Setting up database..."

  # Wait for database to be ready (Railway private networking takes a moment)
  echo "Waiting for database connection..."

  # Extract database connection details from DATABASE_URL
  # Format: postgresql://user:pass@host:port/database
  if [ -n "$DATABASE_URL" ]; then
    DB_HOST=$(echo $DATABASE_URL | sed -e 's|.*@\(.*\):.*|\1|')
    DB_PORT=$(echo $DATABASE_URL | sed -e 's|.*:\([0-9]*\)/.*|\1|')

    MAX_RETRIES=15
    RETRY_COUNT=0

    # Use pg_isready for fast, lightweight database checks
    until pg_isready -h "$DB_HOST" -p "$DB_PORT" -q || [ $RETRY_COUNT -eq $MAX_RETRIES ]; do
      RETRY_COUNT=$((RETRY_COUNT+1))
      # Only log every 5th attempt to avoid Railway rate limit
      if [ $((RETRY_COUNT % 5)) -eq 0 ]; then
        echo "Database not ready yet (attempt $RETRY_COUNT/$MAX_RETRIES), waiting..."
      fi
      sleep 2
    done
  else
    echo "WARNING: DATABASE_URL not set, skipping connection check"
    RETRY_COUNT=0
  fi

  if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
    echo "ERROR: Could not connect to database after $RETRY_COUNT attempts"
    exit 1
  fi

  echo "Database connection established after $RETRY_COUNT attempts!"

  # Run database migrations only (don't run seeds which can take a long time)
  # Seeds with image imports take too long and cause health check timeouts
  echo "Running database migrations..."
  ./bin/rails db:migrate

  # Check if sites need to be imported
  # We check both: 1) if sites exist in DB, and 2) if storage files exist
  # On Railway, the filesystem is ephemeral so storage files may be lost between deploys
  SITE_COUNT=$(./bin/rails runner "puts Site.count" 2>/dev/null || echo "0")

  # Check for actual blob files in storage directory (not just directories)
  # Storage structure is /rails/storage/XX/YY/blob_key where XX/YY are first chars of key
  STORAGE_FILE_COUNT=$(find /rails/storage -type f -name "*" 2>/dev/null | wc -l | tr -d ' ')

  echo "Database sites: $SITE_COUNT, Storage files: $STORAGE_FILE_COUNT"

  if [ "$SITE_COUNT" = "0" ]; then
    echo "Database is empty - will import sites after server starts..."
    export HOOD_MAP_IMPORT_ON_BOOT=1
  elif [ "$STORAGE_FILE_COUNT" = "0" ] || [ "$STORAGE_FILE_COUNT" -lt 5 ]; then
    echo "Database has $SITE_COUNT sites but storage has only $STORAGE_FILE_COUNT files - will rebuild after server starts..."
    export HOOD_MAP_IMPORT_ON_BOOT=1
  else
    echo "Database has $SITE_COUNT sites with $STORAGE_FILE_COUNT storage files - skipping import"
  fi

  echo "Database setup complete"
  echo "HOOD_MAP_IMPORT_ON_BOOT=${HOOD_MAP_IMPORT_ON_BOOT:-not set}"
fi

# Drop privileges and run as rails user using gosu
# This ensures the app runs as non-root for security
exec gosu rails env HOOD_MAP_IMPORT_ON_BOOT="${HOOD_MAP_IMPORT_ON_BOOT:-}" "${@}"
